java是解释型语言
    解释型语言，编译后不能直接被机器执行，需要解释器来执行(js,php,java)。编译型语言,编译后的代码,可以直接被机器执行(c/c++)
jdk,jre,jvm
    jdk = jre + java的开发工具（java, javac, javadoc, javap...）
    jre = jvm + java核心类库(java se标准类库)
MacOS 查看jdk路径
    /usr/libexec/java_home -V
java注意事项
    一个源文件中最多只能有一个public类，其他类的个数不限
    如果源文件包含一个public类，则文件名必须按该类名命名
classpath
    classpath是jvm用到的一个环境变量，它用来只是jvm如何搜索class
    jdk 5 以上则不需要再配置classpath的环境变量。
jar
    实质上是多个class类的压缩包
模块化


===================== 基本数据类型 =====================
java数据类型
    (1个字节等于8位)
    整数类型：byte(1个字节)，short(2个字节)，int(4个字节)，long(8个字节)
    浮点型：float(4个字节)，double(8个字节)
        浮点型在计算机中存放形式：浮点型 = 符号为 + 指数位 + 尾数位
    字符型：char(2个字节)
        字符型的存储：
            存：字符转成码值，然后在将码值转成二进制,最后存入内存。
            取：将二进制转成码值，然后再将码值转换成对应的字符，并输出。
    布尔类型：boolean(1个字节)
        不可以使用0或者非0的整数代替false和true
java基本数据类型的转换
    在进行赋值或运算时，精度小的类型自动换行为精度大的数据类型。
    char -> int -> long -> float -> double
    byte -> short -> int -> long -> float -> double
    char 和 byte,short 之间不发生自动类型转换
    byte,short,char三者在进行计算时，默认会转成int类型
    boolean 不参与自动类型转换
    表达式结果的类型自动提升为操作数中最大的类型
    整数默认为int类型，小数默认为double类型
java基本数据类型的强制类型转换
    将容量大的数据类型转换为容量小的数据类型，会造成精度降低或溢出


=================== 运算符 =========================
自增运算符
    作为独立的语句使用，前++和后++都完全等价与i = i + 1

逻辑运算符
    a&b: 逻辑与；当a和b同时为true，则结果为true,否则为false
    a|b: 逻辑或；当a和b有一个true，则结果为true,否则为false
    a^b: 逻辑异或；当a和b不同时，则结果为true,否则为false

位运算
    &: 按位与；两位都为1，结果才为1，否则为0s
    |: 按位或；两位有一个为1，结果就为1，否则为0
    ^: 按位异或；两位一个为0，一个为1，则为1，否则为0
    ~: 按位取反；位的值为0，则为1，值为1则为0

位运算逻辑(源码，反码，补码)
    二进制的最高位是符号为，0表示整数，1表示负数
    正数的源码，反码，补码都一样
    负数的反码=它源码的符号位不变，其他位取反
    负数的补码=它的反码+1; 负数的反码=它的补码-1；
    在计算机运算的时候，都是已补码的方式来运算的
    我们需要运算结果的时候，我们需要他的源码 



====================== 面向对象 ========================
可变参数： public void fun1 (int i, String ...args) {...}
    可变参数的实参可以为0个或任意多个
    可变参数的实参可以为数组,可变参数的本质就是数组
    可变参数可以和普通类型的参数一起放在形参列表中，但必须保证可变参数在最后
    一个形参列表中只能出现一个可变参数

作用域
    全局变量可以不赋值,直接使用，因为有默认值。局部变量必须赋值后才能使用，因为没有默认值 

构造器
    如果没有定义构造函数，系统会自动给类生成一个无参的默认构造函数.
    一但定义了构造函数，系统自动生成的无参的默认构造函数就会被覆盖,不能使用了

对象属性的初始化顺序
    默认初始化 -> 显式初始化 -> 构造器初始化

访问修饰符
    public: 对外公开的，任何地方都可以使用
    protected: 对子类和同一个包中的类公开
    默认修饰符：对同一个包的类公开
    private: 只有类本身可以访问，不对外公开
    （只有默认和public才能修饰类且符合上述访问权限的特点）

继承
    子类必须调用父类的构造器。完成父类的初始化
    当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，
    则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过
super关键字
    用于访问父类的属性或方法，但是不能访问父类的private的属性和方法
方法重写
    子类的方法参数，方法名称，要和父类方法的参数，方法名称完全一样
    子类方法的返回值和父类方法的返回类型一样，或者是父类返回类型的子类。（比如父类返回类型Object,子类方法返回类型是String）
    子类方法不能缩小父类方法的访问权限

多态
    一个对象的编译类型在定义对象时，就确定，不能改变。运行类型可以变化。
    编译类型看定义时=号的左边，运行类型看=号的右边
    方法的调用看运行类型，属性的调用看编译类型
    属性没有重写之说，属性的值看编译类型   A a = new B()  B是A的子类， a.name  直接去编译类型中的值
    instancesOf 是根据对象的运行类型来比较的

    动态绑定机制
        当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定
        当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

Object
    equals方法
        equals与 == 的区别
            == 既可以判断引用类型也可以判断基本类型，判断基本类型比较值是否相等，判断引用类型比较地址是否相等
            equals只能判断引用类型比较地址是否相等（底层也是调用==）

类变量/类方法

代码块
    修饰符 { ... }; // 修饰符可选，可以写static 或者不写
    static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次
    普通代码块在每创建一个对象，就会执行一次，如果只是使用类的静态成员，普通代码块则不会调用
    静态代码块只能直接调用静态成员。普通代码块可以调用所有成员

    类什么时候被加载
        1. 创建对象实例时（new）
        2. 创建子类对象实例，父类也会被加载
        3. 使用类的静态成员时

    当使用构造器创建对象的时候，都会先调用代码块的内容（代码块的调用优先于构造器）
    代码块的好处
        相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化操作

    创建对象时的调用顺序
        1.先调用静态代码块和静态属性初始化（这两个按照定义顺序调用）
        2.在调用普通代码块和普通属性初始化（这两个按照定义顺序调用）
        3.最后调用构造函数

    创建对象时的调用顺序（存在继承关系）
        1.先调用父类静态代码块和静态属性初始化（这两个按照定义顺序调用）
        2.再调用子类静态代码块和静态属性初始化（这两个按照定义顺序调用）
        3.再调用父类普通代码块和普通属性初始化（这两个按照定义顺序调用）
        4.再调用父类构造方法
        5.再调用子类普通代码块和普通属性初始化（这两个按照定义顺序调用）
        6.最后调用子类的构造方法
    
单例模式 （饿汉式/懒汉式）

final 关键字
    修饰类：final修饰的类不能被继承
    修饰方法：final修饰的方法不能被子类重写
    修饰属性：final修饰的属性不能被修改
    修饰局部变量：final修饰的局部变量不能被修改

    final修饰的属性复制 （非静态）
        只能再申明的时候初始化，
        或者构造器的时候初始化，
        或者再代码块中初始化。
    
    final修饰的静态属性
        只能再声明的时候初始化，
        或者再静态代码块中初始化。
    
    final 和 static同时修饰属性的时候，再使用属性时，不会导致类加载，底层编译器做了优化


抽象类 abstract
    抽象类不能被实例化
    抽象方法不能使用private,final,和static类修饰的，因为这些关键字都是和重写相违背的

模板设计模式

接口 interface
    jdk8后，可以有默认实现方法，需要使用default关键字修饰  default public void test() {...}
    jdk8后，可以有静态方法 public static void cry() { ... }
    接口中的属性必须使用public  final static 修饰符共同修饰
    接口不能继承其他的类，但可以继承其他的接口（支持多继承）

内部类 
    局部内部类
        局部内部类是定义再外部类的局部位置，即方法中或者代码块中。
        可以直接访问外部类的所有成员，包括私有的。
        内部类不能添加修饰符，但是可以添加final关键字
        作用域：仅仅再定义它的方法或代码块中。
        外部其他类不能访问局部内部类（局部内部类地位是一个局部变量）
        外部类和局部内部类的成员重名的时候，默认遵守就近原则，如果访问外部类的成员使用 （外部类名.this.成员） 去访问
    
    匿名内部类
        匿名内部类是定义再外部类的局部位置，即方法中或者代码块中
        匿名内部类可以基于接口 或者 基于类
        可以直接访问外部类的所有成员，包括私有的。
        外部类和匿名内部类的成员重名的时候，默认遵守就近原则，如果访问外部类的成员使用 （外部类名.this.成员） 去访问
    
    成员内部类
        定义再外部类的成员位置。
        可以直接访问外部类的所有成员，包括私有的。
        可以添加任意访问修饰符public, private ...（它的地位就是一个类中的成员）
        外部其他类使用成员内部类的方式：Outer.Inner inner =  outer.new Inner()
        外部类和成员内部类的成员重名的时候，默认遵守就近原则，如果访问外部类的成员使用 （外部类名.this.成员） 去访问
    
    静态内部类
        定义再外部类的成员位置，且用static修饰。
        可以访问外部类所有静态成员，包括私有的，但不能直接访问非静态成员
        可以添加任意访问修饰符public, private ...（它的地位就是一个类中的成员）
        部其他类使用静态内部类的方式：Outer.Inner inner =  new Outer.Inner()
        外部类和静态内部类的成员重名的时候，默认遵守就近原则，如果访问外部类的成员使用 （外部类名.成员） 去访问

枚举
    如果使用enum来实现枚举，要求将定义的常量对象写再类的最前面。
    枚举的name()方法返回常量名
    枚举的ordinal()方法返回定义常量的顺序

注解
============================= 异常 ============================
异常
    必须捕获的异常：exception及其子类，但不包括RuntimeException及其子类。
    不必须捕获的异常：包括Error及其子类，RunTimeException及其子类。

============================= 包装类 ===========================
装箱   Integer i = Integer.valueOf(1);
拆箱   int i2 = i.intValue(i);

jdk 1.5之后 自动装拆箱
    Integer i = 1
    int i2 = i
Integer 的缓存是从 -128 ~ 127

String
    intern():返回字符串对象value属性指向常量池中的地址
    String str = "abc" + "hello";  // 编译器再编译时优化，共 创建一个对象，即 "abchello"

    代码分析
        String a = "abc";
        String b = "hello";
        String c = a + b;
            // 最后一行代码分析: 
                1. 先创建一个StringBuilder sb = new StringBuilder()
                2. 执行 sb.append("abc")
                3. 执行 sb.append("hello")
                4. String c = sb.toString()
    String 常用方法
        equalsIgnoreCase(): 忽略大小写比较
        length():字符串的长度
        indexOf()： 获取字符再字符串中第一次出现的位置，没有则返回-1
        lastIndexOf():字符再字符串中最后一次出现的位置。
        substring():字符串截取
        concat(): 字符串拼接
        replace():字符串替换， 不改变原数据
        split():字符串分割
        toCharArray():将字符串转成字符数组
        String.format(): 字符串格式化， %s: 字符串；  %d 整数；  %.2f 保留2位的小数; %c: char

    StringBuffer 常用方法
        append(): 追加
        delete(index1, index2)：删除索引index1 到 index2的字符，不包含index2
        replace(): 替换
        insert() : 插入
    String 和 StringBuffer转换
        StringBuffer sb = new StringBuffer(str);
        String str = sb.toString()
        String str = new String(sb)


============================= java 常用类 =======================
Arrays  （所有的方法为静态的）
    toString():数组转字符串
    sort(): 数组排序
    copyOf(): 拷贝一个数组中的n个元素
    fill(): 数组的填充，替换原来的元素
    asList(): 数组转list
    arrayscopy():数组拷贝
System 
    currentTimeMillens(): 当前的时间戳（毫秒数）
BigInteger
    add() ：加
    subtract() ：减
    multiply() ： 乘
    divide()：除
BigDecimal
    add() ：加
    subtract() ：减
    multiply() ： 乘
    divide()：除 (需要指定精度)

第一代日期类
    Date
        new Date(): 获取当前时间
        getTime(): 获取时间戳 毫秒
    SimpleDateFormat 格式化时间对象
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-...)
        sdf.format(date)    // 将Date转成String
        sdf.parse() // 将String转成Date 
第二代日期类
    Calendar 日期类

第三代日期类
    LocalDate, LocalTime, LocalDateTime
    DateTimeFormatter.ofPattern():日期格式化

===================== 集合 ========================
