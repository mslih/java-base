java是解释型语言
    解释型语言，编译后不能直接被机器执行，需要解释器来执行(js,php,java)。编译型语言,编译后的代码,可以直接被机器执行(c/c++)
jdk,jre,jvm
    jdk = jre + java的开发工具（java, javac, javadoc, javap...）
    jre = jvm + java核心类库(java se标准类库)
MacOS 查看jdk路径
    /usr/libexec/java_home -V
java注意事项
    一个源文件中最多只能有一个public类，其他类的个数不限
    如果源文件包含一个public类，则文件名必须按该类名命名
java数据类型
    (1个字节等于8位)
    整数类型：byte(1个字节)，short(2个字节)，int(4个字节)，long(8个字节)
    浮点型：float(4个字节)，double(8个字节)
        浮点型在计算机中存放形式：浮点型 = 符号为 + 指数位 + 尾数位
    字符型：char(2个字节)
        字符型的存储：
            存：字符转成码值，然后在将码值转成二进制,最后存入内存。
            取：将二进制转成码值，然后再将码值转换成对应的字符，并输出。
    布尔类型：boolean(1个字节)
        不可以使用0或者非0的整数代替false和true
java基本数据类型的转换
    在进行赋值或运算时，精度小的类型自动换行为精度大的数据类型。
    char -> int -> long -> float -> double
    byte -> short -> int -> long -> float -> double
    char 和 byte,short 之间不发生自动类型转换
    byte,short,char三者在进行计算时，默认会转成int类型
    boolean 不参与自动类型转换
    表达式结果的类型自动提升为操作数中最大的类型
java基本数据类型的强制类型转换
    将容量大的数据类型转换为容量小的数据类型，会造成精度降低或溢出


=================== 运算符 =========================
自增运算符
    作为独立的语句使用，前++和后++都完全等价与i = i + 1

逻辑运算符
    a&b: 逻辑与；当a和b同时为true，则结果为true,否则为false
    a|b: 逻辑或；当a和b有一个true，则结果为true,否则为false
    a^b: 逻辑异或；当a和b不同时，则结果为true,否则为false

位运算
    &: 按位与；两位都为1，结果才为1，否则为0s
    |: 按位或；两位有一个为1，结果就为1，否则为0
    ^: 按位异或；两位一个为0，一个为1，则为1，否则为0
    ~: 按位取反；位的值为0，则为1，值为1则为0

位运算逻辑(源码，反码，补码)
    二进制的最高位是符号为，0表示整数，1表示负数
    正数的源码，反码，补码都一样
    负数的反码=它源码的符号位不变，其他位取反
    负数的补码=它的反码+1; 负数的反码=它的补码-1；
    在计算机运算的时候，都是已补码的方式来运算的
    我们需要运算结果的时候，我们需要他的源码 



====================== 面向对象 ========================
可变参数：
    可变参数的实参可以为0个或任意多个
    可变参数的实参可以为数组,可变参数的本质就是数组
    可变参数可以和普通类型的参数一起放在形参列表中，但必须保证可变参数在最后
    一个形参列表中只能出现一个可变参数

作用域
    全局变量可以不赋值,直接使用，因为有默认值。局部变量必须赋值后才能使用，因为没有默认值 

构造器
    如果没有定义构造函数，系统会自动给类生成一个无参的默认构造函数.
    一但定义了构造函数，系统自动生成的无参的默认构造函数就会被覆盖,不能使用了

对象属性的初始化顺序
    默认初始化 -> 显式初始化 -> 构造器初始化

访问修饰符
    public: 对外公开的，任何地方都可以使用
    protected: 对子类和同一个包中的类公开
    默认修饰符：对同一个包的类公开
    private: 只有类本身可以访问，不对外公开
    （只有默认和public才能修饰类且符合上述访问权限的特点）

继承
    子类必须调用父类的构造器。完成父类的初始化
    当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，
    则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过
super关键字
    用于访问父类的属性或方法，但是不能访问父类的private的属性和方法
方法重写
    子类的方法参数，方法名称，要和父类方法的参数，方法名称完全一样
    子类方法的返回值和父类方法的返回类型一样，或者是父类返回类型的子类。（比如父类返回类型Object,子类方法返回类型是String）
    子类方法不能缩小父类方法的访问权限

多态
    一个对象的编译类型在定义对象时，就确定，不能改变。运行类型可以变化。
    编译类型看定义时=号的左边，运行类型看=号的右边
    方法的调用看运行类型，属性的调用看编译类型
    属性没有重写之说，属性的值看编译类型   A a = new B()  B是A的子类， a.name  直接去编译类型中的值
    instancesOf 是根据对象的运行类型来比较的

    动态绑定机制
        当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定
        当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

Object
    equals方法
        equals与 == 的区别
            == 既可以判断引用类型也可以判断基本类型，判断基本类型比较值是否相等，判断引用类型比较地址是否相等
            equals只能判断引用类型比较地址是否相等（底层也是调用==）

类变量/类方法

代码块
    修饰符 { ... }; // 修饰符可选，可以写static 或者不写
    static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次
    普通代码块在每创建一个对象，就会执行一次，如果只是使用类的静态成员，普通代码块则不会调用

    类什么时候被加载
        1. 创建对象实例时（new）
        2. 创建子类对象实例，父类也会被加载
        3. 使用类的静态成员时

    当使用构造器创建对象的时候，都会先调用代码块的内容（代码块的调用优先于构造器）
    代码块的好处
        相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化操作
        