java是解释型语言
    解释型语言，编译后不能直接被机器执行，需要解释器来执行(js,php,java)。编译型语言,编译后的代码,可以直接被机器执行(c/c++)
jdk,jre,jvm
    jdk = jre + java的开发工具（java, javac, javadoc, javap...）
    jre = jvm + java核心类库(java se标准类库)
MacOS 查看jdk路径
    /usr/libexec/java_home -V
java注意事项
    一个源文件中最多只能有一个public类，其他类的个数不限
    如果源文件包含一个public类，则文件名必须按该类名命名
java数据类型
    (1个字节等于8位)
    整数类型：byte(1个字节)，short(2个字节)，int(4个字节)，long(8个字节)
    浮点型：float(4个字节)，double(8个字节)
        浮点型在计算机中存放形式：浮点型 = 符号为 + 指数位 + 尾数位
    字符型：char(2个字节)
        字符型的存储：
            存：字符转成码值，然后在将码值转成二进制,最后存入内存。
            取：将二进制转成码值，然后再将码值转换成对应的字符，并输出。
    布尔类型：boolean(1个字节)
        不可以使用0或者非0的整数代替false和true
java基本数据类型的转换
    在进行赋值或运算时，精度小的类型自动换行为精度大的数据类型。
    char -> int -> long -> float -> double
    byte -> short -> int -> long -> float -> double
    char 和 byte,short 之间不发生自动类型转换
    byte,short,char三者在进行计算时，默认会转成int类型
    boolean 不参与自动类型转换
    表达式结果的类型自动提升为操作数中最大的类型
java基本数据类型的强制类型转换
    将容量大的数据类型转换为容量小的数据类型，会造成精度降低或溢出


=================== 运算符 =========================
自增运算符
    作为独立的语句使用，前++和后++都完全等价与i = i + 1

逻辑运算符
    a&b: 逻辑与；当a和b同时为true，则结果为true,否则为false
    a|b: 逻辑或；当a和b有一个true，则结果为true,否则为false
    a^b: 逻辑异或；当a和b不同时，则结果为true,否则为false

位运算
    &: 按位与；两位都为1，结果才为1，否则为0s
    |: 按位或；两位有一个为1，结果就为1，否则为0
    ^: 按位异或；两位一个为0，一个为1，则为1，否则为0
    ~: 按位取反；位的值为0，则为1，值为1则为0

位运算逻辑(源码，反码，补码)
    二进制的最高位是符号为，0表示整数，1表示负数
    正数的源码，反码，补码都一样
    负数的反码=它源码的符号位不变，其他位取反
    负数的补码=它的反码+1; 负数的反码=它的补码-1；
    在计算机运算的时候，都是已补码的方式来运算的
    我们需要运算结果的时候，我们需要他的源码 



====================== 面向对象 ========================
可变参数：
    可变参数的实参可以为0个或任意多个
    可变参数的实参可以为数组,可变参数的本质就是数组
    可变参数可以和普通类型的参数一起放在形参列表中，但必须保证可变参数在最后
    一个形参列表中只能出现一个可变参数

作用域
    全局变量可以不赋值,直接使用，因为有默认值。局部变量必须赋值后才能使用，因为没有默认值 

构造器
    如果没有定义构造函数，系统会自动给类生成一个无参的默认构造函数.
    一但定义了构造函数，系统自动生成的无参的默认构造函数就会被覆盖,不能使用了

对象属性的初始化顺序
    默认初始化 -> 显式初始化 -> 构造器初始化

访问修饰符
    public: 对外公开的，任何地方都可以使用
    protected: 对子类和同一个包中的类公开
    默认修饰符：对同一个包的类公开
    private: 只有类本身可以访问，不对外公开
    （只有默认和public才能修饰类且符合上述访问权限的特点）

继承
    子类必须调用父类的构造器。完成父类的初始化
    当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，
    则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过
super关键字
    用于访问父类的属性或方法，但是不能访问父类的private的属性和方法
方法重写
    子类的方法参数，方法名称，要和父类方法的参数，方法名称完全一样
    子类方法的返回值和父类方法的返回类型一样，或者是父类返回类型的子类。（比如父类返回类型Object,子类方法返回类型是String）
    子类方法不能缩小父类方法的访问权限

多态
    一个对象的编译类型在定义对象时，就确定，不能改变。运行类型可以变化。
    编译类型看定义时=号的左边，运行类型看=号的右边
    方法的调用看运行类型，属性的调用看编译类型
    属性没有重写之说，属性的值看编译类型   A a = new B()  B是A的子类， a.name  直接去编译类型中的值
    instancesOf 是根据对象的运行类型来比较的

    动态绑定机制
        当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定
        当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

Object
    equals方法
        equals与 == 的区别
            == 既可以判断引用类型也可以判断基本类型，判断基本类型比较值是否相等，判断引用类型比较地址是否相等
            equals只能判断引用类型比较地址是否相等（底层也是调用==）

类变量/类方法

代码块
    修饰符 { ... }; // 修饰符可选，可以写static 或者不写
    static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次
    普通代码块在每创建一个对象，就会执行一次，如果只是使用类的静态成员，普通代码块则不会调用
    静态代码块只能直接调用静态成员。普通代码块可以调用所有成员

    类什么时候被加载
        1. 创建对象实例时（new）
        2. 创建子类对象实例，父类也会被加载
        3. 使用类的静态成员时

    当使用构造器创建对象的时候，都会先调用代码块的内容（代码块的调用优先于构造器）
    代码块的好处
        相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化操作

    创建对象时的调用顺序
        1.先调用静态代码块和静态属性初始化（这两个按照定义顺序调用）
        2.在调用普通代码块和普通属性初始化（这两个按照定义顺序调用）
        3.最后调用构造函数

    创建对象时的调用顺序（存在继承关系）
        1.先调用父类静态代码块和静态属性初始化（这两个按照定义顺序调用）
        2.再调用子类静态代码块和静态属性初始化（这两个按照定义顺序调用）
        3.再调用父类普通代码块和普通属性初始化（这两个按照定义顺序调用）
        4.再调用父类构造方法
        5.再调用子类普通代码块和普通属性初始化（这两个按照定义顺序调用）
        6.最后调用子类的构造方法
    
单例模式 （饿汉式/懒汉式）

final 关键字
    修饰类：final修饰的类不能被继承
    修饰方法：final修饰的方法不能被子类重写
    修饰属性：final修饰的属性不能被修改
    修饰局部变量：final修饰的局部变量不能被修改

    final修饰的属性复制 （非静态）
        只能再申明的时候初始化，
        或者构造器的时候初始化，
        或者再代码块中初始化。
    
    final修饰的静态属性
        只能再声明的时候初始化，
        或者再静态代码块中初始化。
    
    final 和 static同时修饰属性的时候，再使用属性时，不会导致类加载，底层编译器做了优化


抽象类 abstract
    抽象类不能被实例化
    抽象方法不能使用private,final,和static类修饰的，因为这些关键字都是和重写相违背的

模板设计模式

接口 interface
    jdk8后，可以有默认实现方法，需要使用default关键字修饰  default public void test() {...}
    jdk8后，可以有静态方法 public static void cry() { ... }
    接口中的属性必须使用public  final static 修饰符共同修饰
    接口不能继承其他的类，但可以继承其他的接口（支持多继承）

内部类 
    局部内部类
        局部内部类是定义再外部类的局部位置，即方法中或者代码块中。
        可以直接访问外部类的所有成员，包括私有的。
        内部类不能添加修饰符，但是可以添加final关键字
        作用域：仅仅再定义它的方法或代码块中。
        外部其他类不能访问局部内部类（局部内部类地位是一个局部变量）
        外部类和局部内部类的成员重名的时候，默认遵守就近原则，如果访问外部类的成员使用 （外部类名.this.成员） 去访问
    
    匿名内部类
        匿名内部类是定义再外部类的局部位置，即方法中或者代码块中
        匿名内部类可以基于接口 或者 基于类
        可以直接访问外部类的所有成员，包括私有的。
        外部类和匿名内部类的成员重名的时候，默认遵守就近原则，如果访问外部类的成员使用 （外部类名.this.成员） 去访问
    
    成员内部类
        定义再外部类的成员位置。
        可以直接访问外部类的所有成员，包括私有的。
        可以添加任意访问修饰符public, private ...（它的地位就是一个类中的成员）
        外部其他类使用成员内部类的方式：Outer.Inner inner =  outer.new Inner()
        外部类和成员内部类的成员重名的时候，默认遵守就近原则，如果访问外部类的成员使用 （外部类名.this.成员） 去访问
    
    静态内部类
        定义再外部类的成员位置，且用static修饰。
        可以访问外部类所有静态成员，包括私有的，但不能直接访问非静态成员
        可以添加任意访问修饰符public, private ...（它的地位就是一个类中的成员）
        部其他类使用静态内部类的方式：Outer.Inner inner =  new Outer.Inner()
        外部类和静态内部类的成员重名的时候，默认遵守就近原则，如果访问外部类的成员使用 （外部类名.成员） 去访问

枚举
    如果使用enum来实现枚举，要求将定义常量对象写再最前面。

注解